// REQ: Verification script for feature coverage traceability
// Ensures all BRD requirements have corresponding REQ: tags in code

const fs = require('fs');
const path = require('path');

// Color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m'
};

// Extract all requirement IDs from FEATURES.md
function extractRequirementIds() {
  try {
    const featuresContent = fs.readFileSync('FEATURES.md', 'utf8');
    const ids = featuresContent.match(/BR-[A-Z]+-\d+|FR-[A-Z]+-\d+/g) || [];
    return [...new Set(ids)]; // Remove duplicates
  } catch (error) {
    console.error(`${colors.red}Error reading FEATURES.md:${colors.reset}`, error.message);
    process.exit(1);
  }
}

// Walk directory tree and collect all relevant source files
function walkDirectory(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      // Skip node_modules and other excluded directories
      if (!filePath.includes('node_modules') && 
          !filePath.includes('.git') && 
          !filePath.includes('dist') &&
          !filePath.includes('build')) {
        walkDirectory(filePath, fileList);
      }
    } else if (/\.(ts|tsx|js|jsx|ino|cpp|h|md)$/.test(filePath)) {
      fileList.push(filePath);
    }
  });
  
  return fileList;
}

// Find which files contain REQ tags for each requirement
function findImplementations(requirementIds) {
  const files = walkDirectory(process.cwd());
  const implementations = {};
  
  requirementIds.forEach(id => {
    implementations[id] = [];
  });
  
  files.forEach(filePath => {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      requirementIds.forEach(id => {
        if (content.includes(`REQ: ${id}`)) {
          implementations[id].push(filePath.replace(process.cwd(), '.'));
        }
      });
    } catch (error) {
      // Skip files that can't be read
    }
  });
  
  return implementations;
}

// Generate updated STATUS.md file
function updateStatusFile(requirementIds, implementations) {
  const categories = {
    'BR-FW': 'Firmware',
    'BR-SV': 'Server',
    'BR-UX': 'UI/UX',
    'BR-ST': 'Status',
    'FR-FW': 'Firmware',
    'FR-SV': 'Server',
    'FR-UI': 'UI'
  };
  
  let statusContent = '# Uto Bloom - Implementation Status\n';
  statusContent += `**Last Updated**: ${new Date().toISOString().split('T')[0]} (Auto-generated)\n\n`;
  statusContent += '| Requirement ID | Category | Implemented | Implementation File(s) |\n';
  statusContent += '|---------------|----------|-------------|------------------------|\n';
  
  let implementedCount = 0;
  
  requirementIds.forEach(id => {
    const prefix = id.substring(0, 5);
    const category = categories[prefix] || 'Other';
    const files = implementations[id];
    const isImplemented = files.length > 0;
    
    if (isImplemented) implementedCount++;
    
    const status = isImplemented ? '✅ Yes' : '❌ No';
    const fileLinks = files.length > 0 
      ? files.map(f => `\`${f}\``).join(', ')
      : '-';
    
    statusContent += `| ${id} | ${category} | ${status} | ${fileLinks} |\n`;
  });
  
  const coverage = ((implementedCount / requirementIds.length) * 100).toFixed(2);
  
  statusContent += '\n## Summary\n';
  statusContent += `- **Total Requirements**: ${requirementIds.length}\n`;
  statusContent += `- **Implemented**: ${implementedCount}\n`;
  statusContent += `- **Not Implemented**: ${requirementIds.length - implementedCount}\n`;
  statusContent += `- **Coverage**: ${coverage}%\n\n`;
  statusContent += '---\n';
  statusContent += '*Auto-generated by `npm run verify:features`*\n';
  
  fs.writeFileSync('STATUS.md', statusContent);
  
  return { total: requirementIds.length, implemented: implementedCount, coverage };
}

// Main execution
function main() {
  console.log(`${colors.cyan}╔════════════════════════════════════════╗${colors.reset}`);
  console.log(`${colors.cyan}║  Uto Bloom Feature Coverage Verifier  ║${colors.reset}`);
  console.log(`${colors.cyan}╚════════════════════════════════════════╝${colors.reset}\n`);
  
  // Extract requirement IDs
  console.log(`${colors.blue}[1/4]${colors.reset} Extracting requirement IDs from FEATURES.md...`);
  const requirementIds = extractRequirementIds();
  console.log(`      Found ${colors.green}${requirementIds.length}${colors.reset} unique requirement IDs\n`);
  
  // Find implementations
  console.log(`${colors.blue}[2/4]${colors.reset} Scanning repository for REQ: tags...`);
  const implementations = findImplementations(requirementIds);
  
  // Identify missing implementations
  const missing = requirementIds.filter(id => implementations[id].length === 0);
  const implemented = requirementIds.filter(id => implementations[id].length > 0);
  
  console.log(`      Found implementations for ${colors.green}${implemented.length}${colors.reset} requirements\n`);
  
  // Update STATUS.md
  console.log(`${colors.blue}[3/4]${colors.reset} Updating STATUS.md...`);
  const stats = updateStatusFile(requirementIds, implementations);
  console.log(`      Status file updated\n`);
  
  // Generate report
  console.log(`${colors.blue}[4/4]${colors.reset} Generating coverage report...\n`);
  console.log('─'.repeat(60));
  console.log(`${colors.cyan}COVERAGE SUMMARY${colors.reset}`);
  console.log('─'.repeat(60));
  console.log(`Total Requirements:     ${stats.total}`);
  console.log(`Implemented:            ${colors.green}${stats.implemented}${colors.reset}`);
  console.log(`Not Implemented:        ${colors.yellow}${stats.total - stats.implemented}${colors.reset}`);
  console.log(`Coverage:               ${stats.coverage >= 80 ? colors.green : stats.coverage >= 50 ? colors.yellow : colors.red}${stats.coverage}%${colors.reset}`);
  console.log('─'.repeat(60));
  
  if (missing.length > 0) {
    console.log(`\n${colors.yellow}⚠ WARNING: Missing REQ tags for the following requirements:${colors.reset}\n`);
    missing.forEach(id => {
      console.log(`  ${colors.red}✗${colors.reset} ${id}`);
    });
    console.log(`\n${colors.yellow}Action required:${colors.reset} Add '// REQ: <ID>' comments to implementing files`);
    console.log('─'.repeat(60));
    process.exit(1);
  } else {
    console.log(`\n${colors.green}✓ All requirements have implementation tags!${colors.reset}`);
    console.log('─'.repeat(60));
    process.exit(0);
  }
}

// Run the script
main();
